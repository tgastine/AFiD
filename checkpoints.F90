module checkpoints

   use iso_fortran_env, only: cp => real64
   use mpih
   use decomp_2d
   use local_arrays
   use param
   use hdf5

   implicit none

   private

   public :: ReadFlowField, WriteFlowField

contains


   subroutine ReadFlowField
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                         ! 
!    PURPOSE: Initialization routine. Reads in a flow     !
!     snapshot generated by a previous simulation, and    !
!     interpolates to the current grid if necessary       !
!                                                         !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none
      character*70 :: filnam,dsetname
      integer :: nzom,nyom,nxo,nyo,nzo
      integer :: xs2og,xe2og,xs3og,xe3og
      integer :: istro3
      integer :: vxflag,vyflag,vzflag,teflag,xieflag
!     integer (kind=MPI_ADDRESS_KIND) :: extent,lb
      real(cp) :: stro3
      real(cp), allocatable :: xiold(:,:,:),tempold(:,:,:),vyold(:,:,:)
      real(cp), allocatable :: vxold(:,:,:),vzold(:,:,:)
      logical :: fexist
      
!EP   Reading old grid information by master
      filnam = trim('continua_master.h5')

      inquire(file=filnam,exist=fexist)
      if (.not.fexist) then 
        write(*,*) 'Continuation files not found'
        call MpiAbort
      end if

      if (ismaster) then
       dsetname = trim('nx')
       call HdfSerialReadIntScalar(dsetname,filnam,nxo)
       dsetname = trim('ny')
       call HdfSerialReadIntScalar(dsetname,filnam,nyo)
       dsetname = trim('nz')
       call HdfSerialReadIntScalar(dsetname,filnam,nzo)
       dsetname = trim('time')
       call HdfSerialReadRealScalar(dsetname,filnam,time)
       dsetname = trim('istr3')
       call HdfSerialReadIntScalar(dsetname,filnam,istro3)
       dsetname = trim('str3')
       call HdfSerialReadRealScalar(dsetname,filnam,stro3)
      endif
      
      call MpiBarrier
      call MpiBcastInt(nxo)
      call MpiBcastInt(nyo)
      call MpiBcastInt(nzo)
      call MpiBcastInt(istro3)
      call MpiBcastReal(stro3)
      call MpiBcastReal(time)

!RO   Codes for passing to other routines which variable we are dealing with 
      vxflag = 1
      vyflag = 2
      vzflag = 3
      teflag = 4
      xieflag = 5
      
!EP   Check whether grid specifications have been updated
      if(nyo/=ny.or.nxo/=nx.or.nzo/=nz &
       .or.istro3/=istr3.or.(abs(stro3-str3)>1e-8_cp)) then

       if(ismaster) write(*,*) "Interpolating new grid"

!RO    Using more than double the amount of points results in crashes

       if(nz>nzo*2.or.ny>nyo*2.or.nx>nxo*2) then

        if(ismaster) then 
          write(*,*) "New grid resolution cannot be more ",&
          "than twice the old resolution"
        end if

        call MpiAbort

       endif

!RO   Interpolate

      nyom = nyo - 1
      nzom = nzo - 1
      
      call MpiBarrier

      xs2og = floor(real(xstart(2)*nyom/nym))
      xe2og = ceiling(real(xend(2)*nyom/nym))
      xs3og = floor(real(xstart(3)*nzom/nzm))
      xe3og = ceiling(real(xend(3)*nzom/nzm))

      xs2og = max(xs2og,1)
      xe2og   = min(xe2og,nyom)
      xs3og = max(xs3og,1)
      xe3og   = min(xe3og,nzom)
      
!RO   I think this is deprecated, must check
!     lb=0
!     call MPI_TYPE_GET_EXTENT(MPI_DOUBLE_PRECISION,lb,extent,ierr)


!EP   vz
      allocate(vzold(0:nxo+1,xs2og-lvlhalo:xe2og+lvlhalo, &
        xs3og-lvlhalo:xe3og+lvlhalo))
      
      call HdfReadContinua(nzo,nyo,nxo,xs2og,xe2og, &
       xs3og,xe3og,vzflag,vzold(1:nxo,xs2og-lvlhalo:xe2og+lvlhalo, &
       xs3og-lvlhalo:xe3og+lvlhalo))

      call interp(vzold,vz(1:nx,xstart(2):xend(2),xstart(3):xend(3)) &
       ,nzo,nyo,nxo,istro3,stro3,vzflag,xs2og,xe2og,xs3og,xe3og)

      deallocate(vzold)

!EP   vy
      allocate(vyold(0:nxo+1,xs2og-lvlhalo:xe2og+lvlhalo, &
     & xs3og-lvlhalo:xe3og+lvlhalo))
      
      call HdfReadContinua(nzo,nyo,nxo,xs2og,xe2og, &
     & xs3og,xe3og,vyflag,vyold(1:nxo,xs2og-lvlhalo:xe2og+lvlhalo, &
     & xs3og-lvlhalo:xe3og+lvlhalo))

      call interp(vyold,vy(1:nx,xstart(2):xend(2),xstart(3):xend(3)) &
     & ,nzo,nyo,nxo,istro3,stro3,vyflag,xs2og,xe2og,xs3og,xe3og)

      deallocate(vyold)

!EP   vx
      allocate(vxold(0:nxo+1,xs2og-lvlhalo:xe2og+lvlhalo, &
     & xs3og-lvlhalo:xe3og+lvlhalo))
      
      call HdfReadContinua(nzo,nyo,nxo,xs2og,xe2og, &
     & xs3og,xe3og,vxflag,vxold(1:nxo,xs2og-lvlhalo:xe2og+lvlhalo,  &
     & xs3og-lvlhalo:xe3og+lvlhalo))

      call interp(vxold,vx(1:nx,xstart(2):xend(2),xstart(3):xend(3)) &
     & ,nzo,nyo,nxo,istro3,stro3,vxflag,xs2og,xe2og,xs3og,xe3og)

      deallocate(vxold)

!EP   temp
      allocate(tempold(0:nxo+1,xs2og-lvlhalo:xe2og+lvlhalo, &
     & xs3og-lvlhalo:xe3og+lvlhalo))
      
      call HdfReadContinua(nzo,nyo,nxo,xs2og,xe2og, &
       xs3og,xe3og,teflag,tempold(1:nxo,xs2og-lvlhalo:xe2og+lvlhalo, &
       xs3og-lvlhalo:xe3og+lvlhalo))

      call interp(tempold,temp(1:nx,xstart(2):xend(2),xstart(3):xend(3)) &
       ,nzo,nyo,nxo,istro3,stro3,teflag,xs2og,xe2og,xs3og,xe3og)

      deallocate(tempold)

!EP   xi
      allocate(xiold(0:nxo+1,xs2og-lvlhalo:xe2og+lvlhalo, &
     & xs3og-lvlhalo:xe3og+lvlhalo))
      
      call HdfReadContinua(nzo,nyo,nxo,xs2og,xe2og, &
       xs3og,xe3og,xieflag,xiold(1:nxo,xs2og-lvlhalo:xe2og+lvlhalo, &
       xs3og-lvlhalo:xe3og+lvlhalo))

      call interp(xiold,xi(1:nx,xstart(2):xend(2),xstart(3):xend(3)) &
       ,nzo,nyo,nxo,istro3,stro3,xieflag,xs2og,xe2og,xs3og,xe3og)

      deallocate(xiold)


      else

!EP   Normal one to one HDF read (no interpolation)
      call HdfReadContinua(nz,ny,nx,xstart(2),xend(2) &
     & ,xstart(3),xend(3),vzflag,vz)
      call HdfReadContinua(nz,ny,nx,xstart(2),xend(2) &
     & ,xstart(3),xend(3),vyflag,vy)
      call HdfReadContinua(nz,ny,nx,xstart(2),xend(2) &
     & ,xstart(3),xend(3),vxflag,vx)
      call HdfReadContinua(nz,ny,nx,xstart(2),xend(2) &
     & ,xstart(3),xend(3),teflag,temp)
      call HdfReadContinua(nz,ny,nx,xstart(2),xend(2) &
     & ,xstart(3),xend(3),xieflag,xi)

      endif

      if (resetlogstime) time=0.0_cp

!EP   Increase the maximum simulation time by the end time in the
!continuation files

       tmax = tmax + time

   end subroutine ReadFlowField
!------------------------------------------------------------------------------
   subroutine WriteFlowField
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                         ! 
!    PURPOSE: Write down the full flow snapshot for       !
!     restarting the simulation at a later date           !
!                                                         !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      character*30 :: filnam1,dsetname

      filnam1 = trim('continua_temp.h5')
      call HdfWriteRealHalo3D(filnam1,temp)
      filnam1 = trim('continua_comp.h5')
      call HdfWriteRealHalo3D(filnam1,xi)
      filnam1 = trim('continua_vx.h5')
      call HdfWriteRealHalo3D(filnam1,vx)
      filnam1 = trim('continua_vy.h5')
      call HdfWriteRealHalo3D(filnam1,vy)
      filnam1 = trim('continua_vz.h5')
      call HdfWriteRealHalo3D(filnam1,vz)

      if (ismaster) then !EP only write once
       filnam1 = trim('continua_master.h5')
       call HdfCreateBlankFile(filnam1)
 
       dsetname = trim('nx')
       call HdfSerialWriteIntScalar(dsetname,filnam1,nx)
       dsetname = trim('ny')
       call HdfSerialWriteIntScalar(dsetname,filnam1,ny)
       dsetname = trim('nz')
       call HdfSerialWriteIntScalar(dsetname,filnam1,nz)
       dsetname = trim('ylen')
       call HdfSerialWriteRealScalar(dsetname,filnam1,ylen)
       dsetname = trim('zlen')
       call HdfSerialWriteRealScalar(dsetname,filnam1,zlen)
       dsetname = trim('time')
       call HdfSerialWriteRealScalar(dsetname,filnam1,time)
       dsetname = trim('istr3')
       call HdfSerialWriteIntScalar(dsetname,filnam1,istr3)
       dsetname = trim('str3')
       call HdfSerialWriteRealScalar(dsetname,filnam1,str3)

      endif

   end subroutine WriteFlowField
!------------------------------------------------------------------------------
   subroutine interp(arrold,arrnew,nzo,nyo,nxo,istro3,stro3,intvar,xs2o, &
              &      xe2o,xs3o,xe3o)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                         ! 
!    PURPOSE: Trilinear interpolation to a new grid for   !
!     continuation files. Assumes alx3=1                  !
!                                                         !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      integer :: istro3
      real(cp) :: stro3
      integer,intent(in) :: intvar,nyo,nxo,nzo
      integer,intent(in) :: xs2o,xe2o,xs3o,xe3o
 
      real(cp),intent(out),dimension(1:nx,xstart(2):xend(2), &
     & xstart(3):xend(3)) :: arrnew
      real(cp),dimension(0:nxo+1,xs2o-1:xe2o+1,xs3o-1:xe3o+1) :: arrold
      real(cp),dimension(0:nzo+1) :: tcold,tmold
      real(cp),dimension(1:nz) :: tcnew,tmnew
      real(cp),dimension(0:nyo+1) :: rcold,rmold
      real(cp),dimension(1:ny) :: rcnew,rmnew
      real(cp),dimension(0:nxo+1) :: zzold,zmold
      real(cp),dimension(1:nx) :: zznew,zmnew

      real(cp), dimension(0:nzo+1) :: xold
      real(cp), dimension(0:nyo+1) :: yold
      real(cp), dimension(0:nxo+1) :: zold
      real(cp), dimension(1:nz) :: xnew
      real(cp), dimension(1:ny) :: ynew
      real(cp), dimension(1:nx) :: znew

      real(cp) :: bn(6),an(8)

      real(cp) :: bix1,bix2,biy1,biy2,biz1,biz2,bix,biy,biz
      integer :: j,k,i,l
      real(cp) :: sfcf,sfff,sccf,scff,sfcc,sffc,sccc,scfc
      integer :: bici,bifi,bicj,bifj,bick,bifk

!EP   Create old grid
      call gridnew(nzo,zlen,0,1.0_cp,tcold(1:nzo),tmold(1:nzo))
      call gridnew(nyo,ylen,0,1.0_cp,rcold(1:nyo),rmold(1:nyo))
      call gridnew(nxo,1.0_cp,istro3,stro3,zzold(1:nxo),zmold(1:nxo))

!EP   2nd order extrapolation of grid
      tcold(0) = 2*tcold(1)-tcold(2)
      tcold(nzo+1) = 2*tcold(nzo)-tcold(nzo-1)
      tmold(0) = 2*tmold(1)-tmold(2)
      tmold(nzo+1) = 2*tmold(nzo)-tmold(nzo-1)

      rcold(0) = 2*rcold(1)-rcold(2)
      rcold(nyo+1) = 2*rcold(nyo)-rcold(nyo-1)
      rmold(0) = 2*rmold(1)-rmold(2)
      rmold(nyo+1) = 2*rmold(nyo)-rmold(nyo-1)

      zzold(0) = 2*zzold(1)-zzold(2)
      zzold(nxo+1) = 2*zzold(nxo)-zzold(nxo-1)
      zmold(0) = 2*zmold(1)-zmold(2)
      zmold(nxo+1) = 2*zmold(nxo)-zmold(nxo-1)

!EP   Create new grid
      call gridnew(nz,zlen,0,1.0_cp,tcnew,tmnew)
      call gridnew(ny,ylen,0,1.0_cp,rcnew,rmnew)
      call gridnew(nx,1.0_cp,istr3,str3,zznew,zmnew)
      
      select case (intvar)
          case (1)
             xold=tcold
             yold=rmold
             zold=zmold
             xnew=tcnew
             ynew=rmnew
             znew=zmnew
          case (2)
             xold=tmold
             yold=rcold
             zold=zmold
             xnew=tmnew
             ynew=rcnew
             znew=zmnew
          case (3)
             xold=tmold
             yold=rmold
             zold=zzold
             xnew=tmnew
             ynew=rmnew
             znew=zznew
          case (4)
             xold=tmold
             yold=rmold
             zold=zmold
             xnew=tmnew
             ynew=rmnew
             znew=zmnew
          case (5)
             xold=tmold
             yold=rmold
             zold=zmold
             xnew=tmnew
             ynew=rmnew
             znew=zmnew
      end select

!EP   Extrapolate halo

      do i=xs3o,xe3o
        do j=xs2o,xe2o
          arrold(0    ,j,i)=2.0_cp*arrold(1  ,j,i)-arrold(2,j,i)
          arrold(nxo+1,j,i)=2.0_cp*arrold(nxo,j,i)-arrold(nxo-1,j,i)
        enddo
      enddo

      do j=xs2o,xe2o
        do k=1,nxo
          arrold(k,j,xs3o-1)=2.0_cp*arrold(k,j,xs3o)-arrold(k,j,xs3o+1)
          arrold(k,j,xe3o+1)=2.0_cp*arrold(k,j,xe3o)-arrold(k,j,xe3o-1)
        enddo
      enddo

      do i=xs3o,xe3o
        do k=1,nxo
          arrold(k,xs2o-1,i)=2.0_cp*arrold(k,xs2o,i)-arrold(k,xs2o+1,i)
          arrold(k,xe2o+1,i)=2.0_cp*arrold(k,xe2o,i)-arrold(k,xe2o-1,i)
        enddo
      enddo


!EP   INTERP
      do i=xstart(3),xend(3)
       do j=xstart(2),xend(2)
        do k=1,nx
!c   Find nearest grid value
      bix=xnew(i)
      biy=ynew(j)
      biz=znew(k)

      bifi=nzo-1
      bici=nzo
      do l=1,nzo
      if(xold(l)>=bix) then
      bifi=l-1
      bici=l
      goto 10
      endif
      enddo
10    continue

      bifj=nyo-1
      bicj=nyo
      do l=1,nyo
      if(yold(l)>=biy) then
      bifj=l-1
      bicj=l
      goto 20
      endif
      enddo
20    continue

      bifk=nxo-1
      bick=nxo
      do l=1,nxo
      if(zold(l)>=biz) then
      bifk=l-1
      bick=l
      goto 30
      endif
      enddo
30    continue

!cc   Define
      bix1 = xold(bifi) 
      bix2 = xold(bici)
      biy1 = yold(bifj) 
      biy2 = yold(bicj)
      biz1 = zold(bifk) 
      biz2 = zold(bick)

!EP   Send data

       sfcf = arrold(bifk,bicj,bifi)
       sfff = arrold(bifk,bifj,bifi)
       sccf = arrold(bifk,bicj,bici)
       scff = arrold(bifk,bifj,bici)

       sfcc = arrold(bick,bicj,bifi)
       sffc = arrold(bifk,bifj,bifi)
       sccc = arrold(bifk,bicj,bici)
       scfc = arrold(bifk,bifj,bici)

       an(1) = sfcf
       an(2) = sfff
       an(3) = sccf
       an(4) = scff
       an(5) = sfcc
       an(6) = sffc
       an(7) = sccc
       an(8) = scfc
       bn(1) = bix1
       bn(2) = bix2
       bn(3) = biy1
       bn(4) = biy2
       bn(5) = biz1
       bn(6) = biz2
       call interptrilin(bix,biy,biz,an,bn,arrnew(k,j,i))

        enddo
       enddo
      enddo

   end subroutine interp
!------------------------------------------------------------------------------
   subroutine interptrilin(bix,biy,biz,an,bn,ans)
      
      real(cp), intent(in) :: bix,biy,biz
      real(cp), intent(in) :: bn(6),an(8)
      real(cp), intent(out) :: ans

      real(cp) :: bix1,bix2,biy1,biy2,biz1,biz2
      real(cp) :: afifjck,acifjck,aficjck,acicjck
      real(cp) :: afifjfk,acifjfk,aficjfk,acicjfk,dxdydz
      
      aficjfk = an(1)
      afifjfk = an(2)
      acicjfk = an(3)
      acifjfk = an(4)
      aficjck = an(5)
      afifjck = an(6)
      acicjck = an(7)
      acifjck = an(8)
      
      bix1 = bn(1)
      bix2 = bn(2)
      biy1 = bn(3)
      biy2 = bn(4)
      biz1 = bn(5)
      biz2 = bn(6)

      dxdydz = 1.0_cp/((bix2-bix1)*(biy2-biy1)*(biz2-biz1))

      ans = (aficjfk*(bix2-bix)*(biy-biy1)*(biz2-biz) &
      &     +afifjfk*(bix2-bix)*(biy2-biy)*(biz2-biz) &
      &     +acicjfk*(bix-bix1)*(biy-biy1)*(biz2-biz) &
      &     +acifjfk*(bix-bix1)*(biy2-biy)*(biz2-biz) &
      &     +aficjck*(bix2-bix)*(biy-biy1)*(biz-biz1) &
      &     +afifjck*(bix2-bix)*(biy2-biy)*(biz-biz1) &
      &     +acicjck*(bix-bix1)*(biy-biy1)*(biz-biz1) &
      &     +acifjck*(bix-bix1)*(biy2-biy)*(biz-biz1) &
      &     )*dxdydz

   end subroutine interptrilin
!------------------------------------------------------------------------------
   subroutine gridnew(n,rext,istr,str,rc,rm)

      real(cp), intent(in) :: rext,str
      real(cp), dimension(1:n), intent(out) :: rc,rm
      real(cp), dimension(1:n) :: etaz
      real(cp), dimension(1:n+400) :: etazm
      integer, intent(in) :: n,istr

      real(cp) :: x3,etain,delet,pi
      integer :: i,nxmo,nclip

      if (istr==0) then
        do i=1,n
          x3=real(i-1)/real(n-1)
          rc(i)=rext*x3
        enddo
       endif

      if(istr==6) then
      pi=2.0_cp*asin(1.0_cp)
      nclip = int(str)
      nxmo = n+nclip+nclip
      do i=1,nxmo
        etazm(i)=+cos(pi*(real(i,cp)-0.5_cp)/real(nxmo,cp))
      end do
      do i=1,n
        etaz(i)=etazm(i+nclip)
      end do
      delet = etaz(1)-etaz(n)
      etain = etaz(1)
      do i=1,n
        etaz(i)=etaz(i)/(0.5_cp*delet)
      end do
      rc(1) = 0.0
      do i=2,n-1
        rc(i) = rext*(1.-etaz(i))*0.5_cp
      end do
      rc(n) = rext
      endif


      do i=1,n-1
        rm(i)=(rc(i)+rc(i+1))*0.5_cp
      enddo
      rm(n) = 2*rc(n)-rm(n-1)

   end subroutine gridnew
!------------------------------------------------------------------------------
   subroutine HdfReadContinua(n1o,n2o,n3o,xs2,xe2,xs3,xe3,intvar,qua)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!                                                         ! 
!    PURPOSE: I/O routine. Read in a 3D array in          !
!     parallel of size n1o*n2o*n3o.                       !
!                                                         !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      integer hdf_error

      integer(HID_T) :: file_id
      integer(HID_T) :: slabspace
      integer(HID_T) :: memspace

      integer(HID_T) :: dset_qua

      integer(HSIZE_T) :: dims(3)

      integer(HID_T) :: plist_id
      integer(HSIZE_T), dimension(3) :: data_count  
      integer(HSSIZE_T), dimension(3) :: data_offset 

      integer, intent(in) :: intvar,n1o,n2o,n3o
      integer, intent(in) :: xs2,xe2,xs3,xe3
      integer :: ndims
      real(cp), dimension(1:n3o,xs2-lvlhalo:xe2+lvlhalo, &
       xs3-lvlhalo:xe3+lvlhalo),intent(out)::qua

      character*70 :: filnam1

!EP   Select file and dataset based on intvar

      select case (intvar)
        case (1)
          filnam1 = trim('continua_vx.h5')
        case (2)
          filnam1 = trim('continua_vy.h5')
        case (3)
          filnam1 = trim('continua_vz.h5')
        case (4)
          filnam1 = trim('continua_temp.h5')
        case (5)
          filnam1 = trim('continua_comp.h5')
      end select

!RO   Set offsets and element counts
   
      ndims = 3

      dims(1)=n3o
      dims(2)=n2o-1
      dims(3)=n1o-1

      data_count(1) = n3o
      data_count(2) = xe2-xs2+1
      data_count(3) = xe3-xs3+1

      data_offset(1) = 0
      data_offset(2) = xs2-1
      data_offset(3) = xs3-1

      call h5pcreate_f(H5P_FILE_ACCESS_F, plist_id, &
          hdf_error)

      call h5pset_fapl_mpio_f(plist_id, mpi_comm_world, &
     &  mpi_info_null, hdf_error)

      call h5fopen_f(filnam1, H5F_ACC_RDONLY_F, file_id, &
     & hdf_error, access_prp=plist_id)

      call h5dopen_f(file_id, 'var', &
     &                dset_qua, hdf_error)

      call h5screate_simple_f(ndims, data_count, memspace, hdf_error) 

      call h5dget_space_f(dset_qua, slabspace, hdf_error)
      call h5sselect_hyperslab_f (slabspace, H5S_SELECT_SET_F, &
     &                      data_offset, data_count, hdf_error)
      call h5pcreate_f(H5P_DATASET_XFER_F, plist_id, hdf_error) 
      call h5pset_dxpl_mpio_f(plist_id, H5FD_MPIO_COLLECTIVE_F, &
     &                        hdf_error)
       call h5dread_f(dset_qua, H5T_NATIVE_DOUBLE, &
     &   qua(1:n3o,xs2:xe2,xs3:xe3), dims,  &
     &   hdf_error, file_space_id = slabspace, mem_space_id = memspace,  &
     &   xfer_prp = plist_id)
      call h5pclose_f(plist_id, hdf_error)

      call h5dclose_f(dset_qua, hdf_error)

      call h5sclose_f(memspace, hdf_error)
      call h5fclose_f(file_id, hdf_error)

   end subroutine HdfReadContinua
!------------------------------------------------------------------------------
end module checkpoints
